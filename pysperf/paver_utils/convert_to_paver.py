import csv
import textwrap
from datetime import datetime

import pyomo.environ as pyo
import yaml

from pysperf import _JobResult
from pysperf.config import outputdir, time_format
from pysperf.model_library import models
from pysperf.paver_utils.julian import get_julian_datetime
from pysperf.paver_utils.parse_to_gams import solver_status_to_gams, termination_condition_to_gams_format


def create_solu_file() -> None:
    """
    Creates the pysperf_models.solu file based on optimal and best-solution-known information for each model.
    """
    with outputdir.joinpath("pysperf_models.solu").open('w') as solufile:
        for test_model in models.values():
            if test_model.opt_value is not None:
                soln_type, soln_value = "=opt=", test_model.opt_value
            else:
                soln_type, soln_value = "=best=", test_model.best_value
            print(f"{soln_type}\t{test_model.name}\t{soln_value}", file=solufile)


def create_paver_tracefile(this_run_dir, finished):
    # Create trace file
    trace_header = """\
        * Trace Record Definition
        * GamsSolve
        * InputFileName,SolverName,OptionFile,Direction,NumberOfEquations,NumberOfVariables,NumberOfDiscreteVariables,NumberOfNonZeros,NumberOfNonlinearNonZeros,
        * ModelStatus,SolverStatus,ObjectiveValue,ObjectiveValueEstimate,SolverTime,ETSolver,NumberOfIterations,NumberOfNodes
        """
    trace_data = []
    for model_name, solver_name in finished:
        with this_run_dir.joinpath(solver_name, model_name, "pysperf_result.log").open('r') as resultfile:
            job_result = _JobResult(**yaml.safe_load(resultfile))
        _validate_job_result(job_result)
        test_model = models[model_name]
        trace_line = [
            model_name,  # Model Name
            'MINLP',  # LP, MIP, NLP, etc.
            solver_name,  # ...
            'blank',  # default NLP solver
            'blank',  # default MIP solver
            get_julian_datetime(datetime.strptime(
                job_result.model_build_start_time, time_format)),  # start day/time of job
            0 if test_model.objective_sense == "minimize" else 1,  # direction 0=min, 1=max
            test_model.constraints,  # total number of equations
            test_model.variables,  # total number of variables
            test_model.binary_variables + test_model.integer_variables,  # total number of discrete variables
            'nznum?',  # number of nonzeros
            'nlz?',  # number of nonlinear nonzeros
            0,  # 1= optfile included
            termination_condition_to_gams_format(job_result.termination_condition),
            # GAMS model return status - see the GAMS return codes section.
            solver_status_to_gams(pyo.SolverStatus.ok),  # GAMS solver return status - see the GAMS return codes section.
            job_result.UB,  # value of objective function
            job_result.UB,  # objective function estimate # TODO I think this only works for minimize?
            job_result.solver_run_time,  # resource time used (sec)
            job_result.iterations,  # number of solver iterations
            0,  # dom used
            0,  # nodes used
            '# automatically generated by pysperf'
        ]
        trace_data.append(trace_line)

    with this_run_dir.joinpath("results.trc").open('w') as tracefile:
        tracefile.write(textwrap.dedent(trace_header))
        tracefile.write('*\n')
        csvwriter = csv.writer(tracefile)
        csvwriter.writerows(trace_data)


def _validate_job_result(job_result: _JobResult):
    if job_result.termination_condition is None:
        job_result.termination_condition = pyo.TerminationCondition.unknown
    elif type(job_result.termination_condition) == str:
        job_result.termination_condition = pyo.TerminationCondition(job_result.termination_condition)
